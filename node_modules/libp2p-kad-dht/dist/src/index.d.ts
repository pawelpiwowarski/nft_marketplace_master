export = KadDHT;
/**
 * @typedef {*} Libp2p
 * @typedef {*} PeerStore
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {*} Dialer
 * @typedef {*} Registrar
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {object} PeerData
 * @property {PeerId} id
 * @property {Multiaddr[]} multiaddrs
 */
/**
 * A DHT implementation modeled after Kademlia with S/Kademlia modifications.
 * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.
 */
declare class KadDHT extends EventEmitter {
    /**
     * Create a new KadDHT.
     *
     * @param {Object} props
     * @param {Libp2p} props.libp2p - the libp2p instance
     * @param {Dialer} props.dialer - libp2p dialer instance
     * @param {PeerId} props.peerId - peer's peerId
     * @param {PeerStore} props.peerStore - libp2p peerStore
     * @param {Registrar} props.registrar - libp2p registrar instance
     * @param {string} [props.protocolPrefix = '/ipfs'] - libp2p registrar handle protocol
     * @param {boolean} [props.forceProtocolLegacy = false] - WARNING: this is not recommended and should only be used for legacy purposes
     * @param {number} props.kBucketSize - k-bucket size (default 20)
     * @param {boolean} props.clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)
     * @param {number} props.concurrency - alpha concurrency of queries (default 3)
     * @param {Datastore} props.datastore - datastore (default MemoryDatastore)
     * @param {object} props.validators - validators object with namespace as keys and function(key, record, callback)
     * @param {object} props.selectors - selectors object with namespace as keys and function(key, records)
     * @param {function(import('libp2p-record').Record, PeerId): void} [props.onPut] - Called when an entry is added to or changed in the datastore
     * @param {function(import('libp2p-record').Record): void} [props.onRemove] - Called when an entry is removed from the datastore
     */
    constructor({ libp2p, dialer, peerId, peerStore, registrar, protocolPrefix, forceProtocolLegacy, datastore, kBucketSize, clientMode, concurrency, validators, selectors, onPut, onRemove }: {
        libp2p: Libp2p;
        dialer: Dialer;
        peerId: PeerId;
        peerStore: PeerStore;
        registrar: Registrar;
        protocolPrefix?: string | undefined;
        forceProtocolLegacy?: boolean | undefined;
        kBucketSize: number;
        clientMode: boolean;
        concurrency: number;
        datastore: Datastore;
        validators: object;
        selectors: object;
        onPut?: ((arg0: import("libp2p-record/dist/src/record"), arg1: PeerId) => void) | undefined;
        onRemove?: ((arg0: import("libp2p-record/dist/src/record")) => void) | undefined;
    });
    /**
     * Local reference to the libp2p instance. May be undefined.
     *
     * @type {Libp2p}
     */
    libp2p: Libp2p;
    /**
     * Local reference to the libp2p dialer instance
     *
     * @type {Dialer}
     */
    dialer: Dialer;
    /**
     * Local peer-id
     *
     * @type {PeerId}
     */
    peerId: PeerId;
    /**
     * Local PeerStore
     *
     * @type {PeerStore}
     */
    peerStore: PeerStore;
    /**
     * Local peer info
     *
     * @type {Registrar}
     */
    registrar: Registrar;
    /**
     * Registrar protocol
     *
     * @type {string}
     */
    protocol: string;
    /**
     * k-bucket size
     *
     * @type {number}
     */
    kBucketSize: number;
    _clientMode: boolean;
    /**
     * ALPHA concurrency at which each query path with run, defaults to 3
     *
     * @type {number}
     */
    concurrency: number;
    /**
     * Number of disjoint query paths to use
     * This is set to `kBucketSize`/2 per the S/Kademlia paper
     *
     * @type {number}
     */
    disjointPaths: number;
    /**
     * The routing table.
     *
     * @type {RoutingTable}
     */
    routingTable: RoutingTable;
    /**
     * Reference to the datastore, uses an in-memory store if none given.
     *
     * @type {Datastore}
     */
    datastore: Datastore;
    /**
     * Provider management
     *
     * @type {Providers}
     */
    providers: Providers;
    validators: {
        pk: {
            func: (key: Uint8Array, publicKey: Uint8Array) => Promise<void>;
            sign: boolean;
        };
    };
    selectors: {
        pk: (k: Uint8Array, records: Uint8Array[]) => number;
    };
    network: Network;
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    /**
     * Keeps track of running queries
     *
     * @type {QueryManager}
     */
    _queryManager: QueryManager;
    _running: boolean;
    contentFetching: {
        _putLocal(key: Uint8Array, rec: Uint8Array): Promise<void>;
        put(key: Uint8Array, value: Uint8Array, options?: {
            minPeers?: number | undefined;
        } | undefined): Promise<void>;
        get(key: Uint8Array, options?: {
            timeout?: number | undefined;
        } | undefined): Promise<Uint8Array>;
        getMany(key: Uint8Array, nvals: number, options?: {
            timeout?: number | undefined;
        } | undefined): Promise<{
            val: Uint8Array;
            from: import("peer-id");
        }[]>;
    };
    contentRouting: {
        provide(key: import("multiformats/cid").CID): Promise<void>;
        findProviders(key: import("multiformats/cid").CID, options?: {
            timeout?: number | undefined;
            maxNumProviders?: number | undefined;
        } | undefined): AsyncIterable<{
            id: import("peer-id");
            multiaddrs: import("multiaddr").Multiaddr[];
        }>;
    };
    peerRouting: {
        _findPeerSingle(peer: import("peer-id"), target: import("peer-id")): Promise<Message>;
        findPeer(id: import("peer-id"), options?: {
            timeout?: number | undefined;
        } | undefined): Promise<{
            id: import("peer-id");
            multiaddrs: import("multiaddr").Multiaddr[];
        }>;
        getClosestPeers(key: Uint8Array, options?: {
            shallow?: boolean | undefined;
        } | undefined): AsyncIterable<import("peer-id")>;
        getPublicKey(peer: import("peer-id")): Promise<import("libp2p-crypto").PublicKey>;
    };
    onPut: (arg0: import("libp2p-record/dist/src/record"), arg1: PeerId) => void;
    onRemove: (arg0: import("libp2p-record/dist/src/record")) => void;
    /**
     * Is this DHT running.
     */
    get isStarted(): boolean;
    /**
     * Start listening to incoming connections.
     */
    start(): Promise<[void, void, void, void]>;
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */
    stop(): Promise<[void, void, void, void]>;
    /**
     * Store the given key/value  pair in the DHT.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {Object} [options] - put options
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)
     * @returns {Promise<void>}
     */
    put(key: Uint8Array, value: Uint8Array, options?: {
        minPeers?: number | undefined;
    } | undefined): Promise<void>;
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     *
     * @param {Uint8Array} key
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     * @returns {Promise<Uint8Array>}
     */
    get(key: Uint8Array, options?: {
        timeout?: number | undefined;
    } | undefined): Promise<Uint8Array>;
    /**
     * Get the `n` values to the given key without sorting.
     *
     * @param {Uint8Array} key
     * @param {number} nvals
     * @param {Object} [options] - get options
     * @param {number} [options.timeout] - optional timeout (default: 60000)
     */
    getMany(key: Uint8Array, nvals: number, options?: {
        timeout?: number | undefined;
    } | undefined): Promise<{
        val: Uint8Array;
        from: import("peer-id");
    }[]>;
    /**
     * Remove the given key from the local datastore.
     *
     * @param {Uint8Array} key
     */
    removeLocal(key: Uint8Array): Promise<undefined>;
    /**
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     */
    _putLocal(key: Uint8Array, value: Uint8Array): Promise<void>;
    /**
     * Announce to the network that we can provide given key's value.
     *
     * @param {CID} key
     * @returns {Promise<void>}
     */
    provide(key: CID): Promise<void>;
    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {Object} [options] - findProviders options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds (default: 60000)
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */
    findProviders(key: CID, options?: {
        timeout?: number | undefined;
        maxNumProviders?: number | undefined;
    } | undefined): AsyncIterable<{
        id: PeerId;
        multiaddrs: Multiaddr[];
    }>;
    /**
     * Search for a peer with the given ID.
     *
     * @param {PeerId} id
     * @param {Object} [options] - findPeer options
     * @param {number} [options.timeout=60000] - how long the query should maximally run, in milliseconds (default: 60000)
     * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}
     */
    findPeer(id: PeerId, options?: {
        timeout?: number | undefined;
    } | undefined): Promise<{
        id: PeerId;
        multiaddrs: Multiaddr[];
    }>;
    /**
     * Kademlia 'node lookup' operation.
     *
     * @param {Uint8Array} key
     * @param {Object} [options]
     * @param {boolean} [options.shallow = false] - shallow query
     */
    getClosestPeers(key: Uint8Array, options?: {
        shallow?: boolean | undefined;
    } | undefined): AsyncGenerator<import("peer-id"), void, undefined>;
    /**
     * Get the public key for the given peer id.
     *
     * @param {PeerId} peer
     */
    getPublicKey(peer: PeerId): Promise<import("libp2p-crypto").PublicKey>;
    /**
     * @param {PeerId} peerId
     * @param {Multiaddr[]} multiaddrs
     */
    _peerDiscovered(peerId: PeerId, multiaddrs: Multiaddr[]): void;
    /**
     * Returns the routing tables closest peers, for the key of
     * the message.
     *
     * @param {Message} msg
     */
    _nearestPeersToQuery(msg: Message): Promise<{
        id: import("peer-id");
        multiaddrs: import("multiaddr").Multiaddr[];
    }[]>;
    /**
     * Get the nearest peers to the given query, but iff closer
     * than self.
     *
     * @param {Message} msg
     * @param {PeerId} peerId
     */
    _betterPeersToQuery(msg: Message, peerId: PeerId): Promise<{
        id: import("peer-id");
        multiaddrs: import("multiaddr").Multiaddr[];
    }[]>;
    /**
     * Try to fetch a given record by from the local datastore.
     * Returns the record iff it is still valid, meaning
     * - it was either authored by this node, or
     * - it was received less than `MAX_RECORD_AGE` ago.
     *
     * @param {Uint8Array} key
     */
    _checkLocalDatastore(key: Uint8Array): Promise<import("libp2p-record/dist/src/record") | undefined>;
    /**
     * Add the peer to the routing table and update it in the peerStore.
     *
     * @param {PeerId} peerId
     */
    _add(peerId: PeerId): Promise<void>;
    /**
     * Verify a record without searching the DHT.
     *
     * @param {import('libp2p-record').Record} record
     */
    _verifyRecordLocally(record: import("libp2p-record/dist/src/record")): Promise<void>;
    /**
     * Is the given peer id our PeerId?
     *
     * @param {PeerId} other
     */
    _isSelf(other: PeerId): boolean;
    /**
     * Store the given key/value pair at the peer `target`.
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} rec - encoded record
     * @param {PeerId} target
     */
    _putValueToPeer(key: Uint8Array, rec: Uint8Array, target: PeerId): Promise<void>;
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     */
    _getValueOrPeers(peer: PeerId, key: Uint8Array): Promise<{
        record: import("libp2p-record/dist/src/record");
        peers: PeerData[];
    } | {
        peers: PeerData[];
        record?: undefined;
    }>;
    /**
     * Get a value via rpc call for the given parameters.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     */
    _getValueSingle(peer: PeerId, key: Uint8Array): Promise<Message>;
    /**
     * Verify a record, fetching missing public keys from the network.
     * Calls back with an error if the record is invalid.
     *
     * @param {import('libp2p-record').Record} record
     * @returns {Promise<void>}
     */
    _verifyRecordOnline(record: import("libp2p-record/dist/src/record")): Promise<void>;
}
declare namespace KadDHT {
    export { multicodec, Libp2p, PeerStore, PeerId, Datastore, Dialer, Registrar, CID, Multiaddr, PeerData };
}
import { EventEmitter } from "events";
type Libp2p = any;
type Dialer = any;
type PeerId = import('peer-id');
type PeerStore = any;
type Registrar = any;
import RoutingTable = require("./routing-table");
type Datastore = import('interface-datastore').Datastore;
import Providers = require("./providers");
import Network = require("./network");
import QueryManager = require("./query-manager");
import Message = require("./message");
type CID = import('multiformats/cid').CID;
type Multiaddr = import('multiaddr').Multiaddr;
type PeerData = {
    id: PeerId;
    multiaddrs: Multiaddr[];
};
declare var multicodec: string;
//# sourceMappingURL=index.d.ts.map