export = RoutingTable;
/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */
declare class RoutingTable {
    /**
     * @param {import('../')} dht
     * @param {object} [options]
     * @param {number} [options.kBucketSize=20]
     * @param {number} [options.refreshInterval=30000]
     */
    constructor(dht: import('../'), { kBucketSize, refreshInterval }?: {
        kBucketSize?: number | undefined;
        refreshInterval?: number | undefined;
    } | undefined);
    peerId: PeerId;
    dht: import("../");
    _kBucketSize: number;
    _refreshInterval: number;
    /** @type {KBucketTree} */
    kb: KBucketTree;
    /** @type {Date[]} */
    commonPrefixLengthRefreshedAt: Date[];
    /**
     * To speed lookups, we seed the table with random PeerIds. This means
     * when we are asked to locate a peer on the network, we can find a KadId
     * that is close to the requested peer ID and query that, then network
     * peers will tell us who they know who is close to the fake ID
     *
     * @param {boolean} [force=false]
     */
    _refreshTable(force?: boolean | undefined): Promise<void>;
    /**
     * Called on the `ping` event from `k-bucket`.
     * Currently this just removes the oldest contact from
     * the list, without actually pinging the individual peers.
     * This is the same as go does, but should probably
     * be upgraded to actually ping the individual peers.
     *
     * @param {KBucketPeer[]} oldContacts
     * @param {KBucketPeer} newContact
     */
    _onPing(oldContacts: KBucketPeer[], newContact: KBucketPeer): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    _refreshTimeoutId: NodeJS.Timeout | undefined;
    /**
     * @param {number} cpl
     * @param {Date} lastRefresh
     * @param {boolean} force
     */
    _refreshCommonPrefixLength(cpl: number, lastRefresh: Date, force: boolean): Promise<void>;
    /**
     * @param {number} maxCommonPrefix
     */
    _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix: number): Date[];
    /**
     *
     * @param {number} targetCommonPrefixLength
     */
    _generateRandomPeerId(targetCommonPrefixLength: number): Promise<PeerId>;
    /**
     * @param {Uint8Array} localKadId
     * @param {number} randomPrefix
     * @param {number} targetCommonPrefixLength
     */
    _makePeerId(localKadId: Uint8Array, randomPrefix: number, targetCommonPrefixLength: number): Promise<Uint8Array>;
    /**
     * returns the maximum common prefix length between any peer in the table
     * and the current peer
     */
    _maxCommonPrefix(): number;
    /**
     * Returns the number of peers in the table with a given prefix length
     *
     * @param {number} prefixLength
     */
    _numPeersForCpl(prefixLength: number): number;
    /**
     * Yields the common prefix length of every peer in the table
     */
    _prefixLengths(): Generator<number, void, unknown>;
    /**
     * Amount of currently stored peers.
     */
    get size(): number;
    /**
     * Find a specific peer by id.
     *
     * @param {PeerId} peer
     */
    find(peer: PeerId): Promise<PeerId | undefined>;
    /**
     * Retrieve the closest peers to the given key.
     *
     * @param {Uint8Array} key
     */
    closestPeer(key: Uint8Array): PeerId | undefined;
    /**
     * Retrieve the `count`-closest peers to the given key.
     *
     * @param {Uint8Array} key
     * @param {number} count
     */
    closestPeers(key: Uint8Array, count: number): PeerId[];
    /**
     * Add or update the routing table with the given peer.
     *
     * @param {PeerId} peer
     */
    add(peer: PeerId): Promise<void>;
    /**
     * Remove a given peer from the table.
     *
     * @param {PeerId} peer
     */
    remove(peer: PeerId): Promise<void>;
}
declare namespace RoutingTable {
    export { KBucketPeer, KBucket, KBucketTree };
}
import PeerId = require("peer-id");
type KBucketTree = {
    root: KBucket;
    localNodeId: Uint8Array;
    on: (event: string, callback: Function) => void;
    closest: (key: Uint8Array, count: number) => KBucketPeer[];
    closestPeer: (key: Uint8Array) => KBucketPeer;
    remove: (key: Uint8Array) => void;
    add: (peer: KBucketPeer) => void;
    count: () => number;
    toIterable: () => Iterable<KBucket>;
};
type KBucketPeer = {
    id: Uint8Array;
    peer: PeerId;
};
type KBucket = {
    id: Uint8Array;
    contacts: KBucketPeer[];
    dontSplit: boolean;
    left: KBucket;
    right: KBucket;
};
//# sourceMappingURL=index.d.ts.map