'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var version = require('../version.js');
var multiaddr = require('multiaddr');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var toString = require('uint8arrays/to-string');
var PeerId = require('peer-id');
var errors = require('../errors.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);

function createId({peerId, network}) {
  async function id(options = {}) {
    if (options.peerId === peerId.toB58String()) {
      delete options.peerId;
    }
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new errors.NotStartedError();
      }
      const idStr = peerId.toB58String();
      return {
        id: idStr,
        publicKey: toString.toString(peerId.pubKey.bytes, 'base64pad'),
        addresses: [],
        agentVersion: `js-ipfs/${ version.ipfsCore }`,
        protocolVersion: '9000',
        protocols: []
      };
    }
    const id = options.peerId ? PeerId__default["default"].createFromB58String(options.peerId.toString()) : peerId;
    const {libp2p} = net;
    const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id) : id.pubKey;
    const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id) : libp2p.multiaddrs;
    const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id) : Array.from(libp2p.upgrader.protocols.keys());
    const agentVersion = toString.toString(libp2p.peerStore.metadataBook.getValue(id, 'AgentVersion') || new Uint8Array());
    const protocolVersion = toString.toString(libp2p.peerStore.metadataBook.getValue(id, 'ProtocolVersion') || new Uint8Array());
    const idStr = id.toB58String();
    return {
      id: idStr,
      publicKey: toString.toString(publicKey.bytes, 'base64pad'),
      addresses: (addresses || []).map(ma => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${ idStr }`)) {
          return str;
        }
        return `${ str }/p2p/${ idStr }`;
      }).sort().map(ma => new multiaddr.Multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (protocols || []).sort()
    };
  }
  return withTimeoutOption.withTimeoutOption(id);
}

exports.createId = createId;
