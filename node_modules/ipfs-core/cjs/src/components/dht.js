'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var errCode = require('err-code');
var errors = require('../errors.js');
var get = require('dlv');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);

function createDht({network, repo}) {
  const {get, put, findProvs, findPeer, provide, query} = {
    async get(key, options = {}) {
      const {libp2p} = await use(network, options);
      return libp2p._dht.get(key, options);
    },
    async *put(key, value, options) {
      const {libp2p} = await use(network, options);
      yield* libp2p._dht.put(key, value);
    },
    async *findProvs(cid, options = { numProviders: 20 }) {
      const {libp2p} = await use(network, options);
      for await (const peer of libp2p._dht.findProviders(cid, {
          maxNumProviders: options.numProviders,
          signal: options.signal
        })) {
        yield {
          id: peer.id.toB58String(),
          addrs: peer.addrs
        };
      }
    },
    async findPeer(peerId, options) {
      const {libp2p} = await use(network, options);
      const peer = await libp2p._dht.findPeer(PeerId__default["default"].parse(peerId));
      return {
        id: peer.id.toB58String(),
        addrs: peer.multiaddrs
      };
    },
    async *provide(cids, options = { recursive: false }) {
      const {libp2p} = await use(network, options);
      const cidArr = Array.isArray(cids) ? cids : [cids];
      const hasCids = await Promise.all(cidArr.map(cid => repo.blocks.has(cid)));
      const hasAll = hasCids.every(has => has);
      if (!hasAll) {
        throw errCode__default["default"](new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');
      }
      if (options.recursive) {
        throw errCode__default["default"](new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');
      }
      for (const cid of cidArr) {
        yield libp2p._dht.provide(cid);
      }
    },
    async *query(peerId, options) {
      const {libp2p} = await use(network, options);
      for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId__default["default"].parse(peerId).toBytes())) {
        yield {
          id: closerPeerId.toB58String(),
          addrs: []
        };
      }
    }
  };
  return {
    get: withTimeoutOption.withTimeoutOption(get),
    put: withTimeoutOption.withTimeoutOption(put),
    findProvs: withTimeoutOption.withTimeoutOption(findProvs),
    findPeer: withTimeoutOption.withTimeoutOption(findPeer),
    provide: withTimeoutOption.withTimeoutOption(provide),
    query: withTimeoutOption.withTimeoutOption(query)
  };
}
const use = async (network, options) => {
  const net = await network.use(options);
  if (get__default["default"](net.libp2p, '_config.dht.enabled', false)) {
    return net;
  } else {
    throw new errors.NotEnabledError('dht not enabled');
  }
};

exports.createDht = createDht;
